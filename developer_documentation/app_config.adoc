= App config
:toc:

link:/developer_documentation/start.adoc[Back to documentation home]

== App configuration

The application environment is set in the `RACK_ENV` environment variable.

Environments can be:

* development (default)
* production
* test

Environment variable loading uses the dotenv gem (https://github.com/bkeepers/dotenv).

Development environment variables are set in the `.env` file in the root dir.

Per-machine overrides can be specified in a `.env.local` file (which is not checked in to version control).

=== Client settings

Client settings are defined in the `.env.local` file on the client's server.

Rules for environment variables are defined in `config/env_var_rules`. Whenever a new client setting is required, this file must be updated with the variable and its description.

Environment variables are classified in one of the folowing ways:

NO_OVERRIDE :: These are set in .env file and are fixed - never to be changed. e.g. `APP_CAPTION`.
CAN_OVERRIDE :: These are set in `.env`, but can be changed in `.env.local`. e.g. `DATABASE_URL`.
MUST_OVERRIDE :: These are not set in `.env` - only in `.env.local` and they are required. e.g. `SYSTEM_MAIL_SENDER`.
OPTIONAL :: These are optinal settings (typically for developers only) that do not have to be present. e.g. `LOGSQLTOFILE`.


Use `bundle exec rake developers:setup` to get `.env.local` to add any required environment variables that are missing.

=== AppConst

This file (`config/app_const.rb`) stores "global" constants for use throuhgout the application.

Reference a constant in code like this:
[source,ruby]
----
AppConst::CLIENT_CODE
----

.config/app_const.rb
[source,ruby]
----
class AppConst
  # Client-specific code
  CLIENT_CODE = ENV.fetch('CLIENT_CODE')
  IMPLEMENTATION_OWNER = ENV.fetch('IMPLEMENTATION_OWNER')   <1>

  # Constants for roles:
  ROLE_IMPLEMENTATION_OWNER = 'IMPLEMENTATION_OWNER'         <2>
  ROLE_CUSTOMER = 'CUSTOMER'

  # Que
  QUEUE_NAME = ENV.fetch('QUEUE_NAME', 'default')            <3>

  # Boolean settings
  USE_BINS = make_boolean('USE_BINS')                        <4>
  USE_BINS = make_boolean('USE_BINS', required: true)        <5>
  USE_BINS = make_boolean('USE_BINS', default_true: true)    <6>
end
----
<1> Set a constant from a required environment variable. If not set, the application will raise an exception and not start.
<2> A string constant value. (Not configurable via environment variable)
<3> This constant is supplied by the environment variable but has a default value if there is no ENV var.
<4> This will be true/false and defaults to `false`. Environment variables that start with t/T/y/Y (True, Yes, y, yabba dabba doo) will be set to `true` - any others will be `false`.
<5> This will be true/false and will raise an exception (which prevents the app from starting) if the environment variable is not set.
<6> This will be true/false and defaults to `true` instead of false.

== Client Rules

Client rules are a special case of AppConst.

A set of client rules are defined in a class in `lib/client_rules`. This class is instantiated in AppConst as a constant whose name begins with `CR_`.
Methods are called on the constant to check behaviour rules for the current client (as defined in the environment variable `CLIENT_CODE`).

These classes must follow the following rules:

1. Part of `Crossbeams` module.
2. Name is made up of three parts - `Client`, descriptive and `Rules` (e.g. `ClientRunRules`)
3. Inherit from `BaseClassRules`.
4. `include Crossbeams::AutoDocumentation`.
5. Implement a constant named `CLIENT_SETTINGS` - hash where keys are the `CLIENT_CODE` as a symbol and the values are hashes of settings and their values.
6. Initialize method must set `@settings` to the `CLIENT_SETTINGS` value for the passed-in `client_code` converted to a symbol.
7. Each method must implement the arg: `explain: false`.
8. Each method must return a string explaning the method if it is called with `explain: true`.
9. The method body should return something relevant to the calling code otherwise.
10. Client settings that just return their value do not have to be defined in methods. They are still called as methods though.

=== Testing code that relies on client rules.

AppConst implements a constant named `TEST_SETTINGS` with an attribute named `client_code` defaulted to the current `CLIENT_CODE`.
When a test is run, this client code can be changed to test different behaviour for another client.

e.g. This code expects different values for `allocation_required` for two different clients:
[source,ruby]
----
def test_create_production_run
  attrs = fake_production_run.to_h.reject { |k, _| k == :id }
  AppConst::TEST_SETTINGS.client_code = 'hl'
  id = repo.create_production_run(attrs)
  alloc = repo.get(:production_runs, id, :allocation_required)
  assert alloc

  AppConst::TEST_SETTINGS.client_code = 'hb'
  id = repo.create_production_run(attrs)
  alloc = repo.get(:production_runs, id, :allocation_required)
  refute alloc
end
----

=== Example client rules

[source,ruby]
----
module Crossbeams
  class ClientRunRules < BaseClientRules
    include Crossbeams::AutoDocumentation

    CLIENT_SETTINGS = {
      hb: { run_allocations: false,
            packing_container: 'CARTON' },
      hl: { run_allocations: true,
            packing_container: 'BIN' }
    }.freeze

    def initialize(client_code)
      @settings = CLIENT_SETTINGS.fetch(client_code.to_sym)
    end

    def no_run_allocations?(explain: false)
      return 'Does this client not do allocation of product setup to resource?' if explain

      !setting(:run_allocations)
    end
  end
end

> CR_RUN = Crossbeams::ClientRunRules.new('hb')
# => #<Crossbeams::ClientRunRules:0x000055a76a51d9e0 @settings={:run_allocations=>false, :packing_container=>"CARTON"}>
> CR_RUN.no_run_allocations?(explain: true)
# => "Does this client not do allocation of product setup to resource?"
> CR_RUN.no_run_allocations?
# => true
> CR_RUN.packing_container(explain: true)
# => "Packing container"
> CR_RUN.packing_container
# => "CARTON"

----
